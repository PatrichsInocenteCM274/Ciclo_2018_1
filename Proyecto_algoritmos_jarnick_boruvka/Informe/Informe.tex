\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{wrapfig, blindtext}
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{listings}
\lstset{ frame=Ltb,
framerule=0pt,
aboveskip=0.5cm,
framextopmargin=3pt,
framexbottommargin=3pt,
framexleftmargin=0.4cm,
framesep=0pt,
rulesep=.4pt,
backgroundcolor=\color{gray97},
rulesepcolor=\color{black},
%
stringstyle=\ttfamily,
showstringspaces = false,
basicstyle=\small\ttfamily,
commentstyle=\color{gray45},
keywordstyle=\bfseries,
%
numbers=left,
numbersep=15pt,
numberstyle=\tiny,
numberfirstline = false,
breaklines=true,
}

% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
{\lstset{#1}\pagebreak[0]}{\pagebreak[0]}

\lstdefinestyle{consola}
{basicstyle=\scriptsize\bf\ttfamily,
backgroundcolor=\color{gray75},
}

\lstdefinestyle{C}
{language=C,
}
%Caratula
\usepackage{scrextend}
\changefontsizes[18pt]{11pt}
\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{-0.4in}

{\fontsize{13}{30}\bf \selectfont UNIVERSIDAD NACIONAL DE INGENIERIA\\}

{\fontsize{13}{40}\bf \selectfont FACULTAD DE CIENCIAS\\}
\vspace*{0.15in} ESCUELA PROFESIONAL DE CIENCIAS DE LA COMPUTACI\'ON\\
\vspace*{0.04in}
\vspace*{0.15in} ESCUELA PROFESIONAL DE MATEM\'ATICA\\
\vspace*{0.1in}
\begin{figure}[htb]
\begin{center}
\includegraphics[width=4.5cm,height=5.5cm]{UNI.png}
\end{center}
\end{figure}
\begin{Large}
\textbf{ALGORITMOS DE JARNICK Y BORUVKA\\}
\end{Large}
\vspace*{0.2in}

\begin{large}
{\bf T\'itulo del Trabajo\\}
\vspace*{0.1in}
{\fontsize{13}{13}\selectfont 
Encontrando el Arbol generador minimal de un grafo, mediante la implementaci\'on de los algoritmos de Jarnick y Boruvka en lenguaje C\\}
\end{large}
\vspace*{0.1in}

\begin{large}
{\bf Autores} 
\vspace*{0.1in}
\\Rojas D\'iaz, Ivan\\
Pantoja, Fabio \\Alarco, Andrew\\
Inocente Valle, Patrichs
\end{large}

\vspace*{0.4in}
\begin{large}
{\bf Profesor} 
\vspace*{0.1in}
\\Echegaray Castillo, William Carlos
\end{large}

\end{center}
\begin{center}
\begin{large}
\vspace*{0.2in}
Lima - Peru\\
{\bf JUNIO 2018}
\end{large}
\end{center}
\end{titlepage}

\pagebreak
\tableofcontents
\pagebreak

\section{Resumen}
\subsection{ARBOL GENERADOR MINIMAL}
\subsubsection{Conceptos Generales}
\section{Implementaci\'on en lenguaje C}
\subsection{Algoritmo de Jarnick mediante Arrays}
\subsubsection{Pseudoc\'odigo del algoritmo}
\subsubsection{C\'odigo de Programa}


\begin{lstlisting}[style=C]
#include<stdio.h>
#include<stdlib.h>

void main(){
FILE* fichero;
int i,j,k;           
int n,opcion;			   
int respaldo1,respaldo2; 			        
int menor;   
int *V;			 
int **adya,**peso;	    

do{
//MENU PARA ELEGIR GRAFO A EVALUAR:
do{
printf("Elige el grafo a evaluar:\n1. Grafo1\n2. Grafo2\n3. Grafo3\n4. Grafo4\n5. Grafo5\n6. No elegir y Salir\n");
scanf("%d",&opcion);
switch(opcion){
case 1  :fichero = fopen("Grafo1.txt", "rt");break;
case 2  :fichero = fopen("Grafo2.txt", "rt");break;
case 3  :fichero = fopen("Grafo3.txt", "rt");break;
case 4  :fichero = fopen("Grafo4.txt", "rt");break;
case 5  :fichero = fopen("Grafo5.txt", "rt");break;
case 6  :printf("ADIOS\n");break;
default :printf("Opcion incorrecta! VUELVA A INTENTARLO\n\n");break;
}
}while(opcion<1||opcion>6);
//RESERVA DE MEMORIA:
if(opcion!=6){
fscanf(fichero,"%d",&n);

adya = (int **) malloc (n * sizeof(int *));
for (k=0 ; k < n ; k++) {
    adya[k] = (int *) malloc (n * sizeof(int));
}

peso = (int **) malloc (n * sizeof(int *));
for (k=0 ; k < n ; k++) {
    peso[k] = (int *) malloc (n * sizeof(int));
}

V = (int *) malloc (n * sizeof(int));

// INICIALIZAVION DEL CONJUNTO V: 

V[0]=1;
for (k=1 ; k < n ; k++) V[k]=0;

// LECTURA DE LAS MATRICES:
for(i=0;i<n;i++)
for(j=0;j<n;j++)fscanf (fichero, "%d",&adya[i][j]);
for(i=0;i<n;i++)
for(j=0;j<n;j++)fscanf (fichero, "%d",&peso[i][j]);


// ALGORITMO:

printf("\n\nResultado del Algoritmo:\n");
printf("------------------------------------------------------------------\n\n");
printf("E0={}\n\nV0={1}\n\n");
for(k=0;k<n-1;k++){
	menor=10000;
	for(i=0;i<n;i++){
	    if(V[i]==1){
 	       for(j=0;j<n;j++){  
	           if (peso[i][j]< menor && adya[i][j]==1 && V[i]!=V[j]){
					 menor=peso[i][j];
					 respaldo1=i;
				         respaldo2=j;
                   }
	       }
 
	    }

        }
adya[respaldo1][respaldo2]=adya[respaldo2][respaldo1]=2;
V[respaldo2]=1;

// MOSTRAMOS EL CONJUNTO DE ARISTAS Y DE VERTICES SELECCIONADOS
// HASTA LA K-ESIMA ITERACION DEL ALGORITMO:
printf("------------------------------------------------------------------\n\n");
printf("E%d={",k+1);
for(i=0;i<n;i++){
  for(j=i;j<n;j++) if(adya[i][j]==2) printf("{%d,%d},",i+1,j+1);
}
printf("\b}\n\nV%d={",k+1);
for(i=0;i<n;i++)  if(V[i]==1)  printf("%d,",i+1);
  printf("\b}\n\n");
} 
printf("\n");
// FIN DE ALGORITMO.
}
printf("------------------------------------------------------------------\n\n");
}while(opcion!=6);
} // FIN DE PROGRAMA.
\end{lstlisting}

\subsection{Algoritmo de Jarnick mediante Estructuras}
\subsubsection{Pseudoc\'odigo del algoritmo}
\subsubsection{C\'odigo de Programa}
\subsection{Algoritmo de Boruvka mediante Arrays}
\subsubsection{Pseudoc\'odigo del algoritmo}
\subsubsection{C\'odigo de Programa}
\begin{lstlisting}[style=C]
#include<stdio.h>
#include<stdlib.h>

void main(){


//VARIABLES A USAR:
FILE* fichero;
int i,j,k,l,t,contador;           
int n,bandera,opcion;			   
int x,y; 			        
int menor;   
char *V,*Va;   // Los usaremos como vectores de etiquetas.
int *registro; // registra que vertices han sido pintados.			 
int **adya,**peso,**Arbol;	

do{
//MENU PARA ELEGIR GRAFO A EVALUAR:

do{
printf("\n\nElige el grafo a evaluar:\n1. Grafo1\n2. Grafo2\n3. Grafo3\n4. Grafo4\n5. Grafo5\n6. No elegir y Salir\n");
scanf("%d",&opcion);
switch(opcion){
case 1  :fichero = fopen("Grafo1.txt", "rt");break;
case 2  :fichero = fopen("Grafo2.txt", "rt");break;
case 3  :fichero = fopen("Grafo3.txt", "rt");break;
case 4  :fichero = fopen("Grafo4.txt", "rt");break;
case 5  :fichero = fopen("Grafo5.txt", "rt");break;
case 6  :printf("Gracias por su visita.\n");break;
default :printf("Opcion incorrecta! VUELVA A INTENTARLO\n\n");break;
}
}while(opcion<1||opcion>6);
//RESERVA DE MEMORIA:
if(opcion!=6){ 
bandera=1;
fscanf(fichero,"%d",&n);

adya = (int **) malloc (n * sizeof(int *));
for (k=0 ; k < n ; k++) adya[k] = (int *) malloc (n * sizeof(int));

peso = (int **) malloc (n * sizeof(int *));
for (k=0 ; k < n ; k++) peso[k] = (int *) malloc (n * sizeof(int));

Arbol = (int **) malloc (n * sizeof(int *));
for (k=0 ; k < n ; k++) Arbol[k] = (int *) malloc (n * sizeof(int));

V = (char *) malloc (n * sizeof(char));  

registro = (int *) malloc (n * sizeof(int));

Va = (char *) malloc (n * sizeof(char)); 


// INICIALIZACION DE CONJUNTOS Y MATRICES: 

for (k=0 ; k < n ; k++) V[k]='a'+k; 
for (k=0 ; k < n ; k++) Va[k]='a'+k;
for (k=0 ; k < n ; k++) registro[k]=0;
for (i=0 ; i < n ; i++) for (j=0 ; j < n ; j++) Arbol[i][j]=0;


// LECTURA DE LAS MATRICES:

for(i=0;i<n;i++) for(j=0;j<n;j++) fscanf (fichero, "%d",&adya[i][j]);

for(i=0;i<n;i++) for(j=0;j<n;j++) fscanf (fichero, "%d",&peso[i][j]);


// ALGORITMO:

printf("\n\nResultado del Algoritmo:\n");
printf("\n------------------------------------------------------------------\n\nE0={}\n");
contador=1;
while(bandera==1){
bandera=0;
printf("\nV={");
for(t=0;t<n;t++)printf("%d, ",t+1);
printf("\b\b}\n   ");
for(t=0;t<n;t++){
if((t+1)/10==0)printf("%c  ",V[t]);
else printf(" %c  ",V[t]);
}
printf("\n------------------------------------------------------------------");
printf("\n");
for (k=0 ; k < n ; k++){   // Recorre todas las componentes con etiqueta k.
	menor=10000; 
    for (i=0 ; i < n ; i++){
        if(V[i]=='a'+k){   // Evalua solo los vertices "i" que tienen la etiqueta k.
			    
        // Calculamos la arista con menor peso,saliendo de cualquier vertice 
        // de la componente k,salvando la posicion con las variables x e y.
    	  for(j=0;j<n;j++){
	      if (adya[i][j]==1 && menor>peso[i][j] && V[i]!=V[j]){
		 menor=peso[i][j];
		 x=i; 
		 y=j;
                 
	         }
              }
          } 
   }
// Luego de tener una arista nueva,dos componentes se vuelven una,y *Va 
// guarda la nueva configuracion de etiquetas:
 registro[x]=1; // Se deja registro de que pasamos por el vertice x.

//-> Si el vertice "y" ya ha sido pintado:
 if(registro[y]==1){ 
// Pintamos todas las etiquetas que tienen valor V[x] con Va[y]
 for(t=0;t<n;t++)if(Va[t]==Va[x])Va[t]=Va[y]; 

 }         
           
//-> Si el vertice "y" aun no ha sido pintado:
 else {            
// Pintamos todas las etiquetas que tienen valor V[y] con Va[x]  
 for(t=0;t<n;t++)if(Va[t]==V[y])Va[t]=Va[x]; 
  
 registro[y]=1; // Registramos que estamos pintando el vertice y.
 }
 Arbol[x][y]=Arbol[y][x]=1; // La arista se registra en nuestro arbol.
}

// Se actualiza el vector de etiquetas con el vector de etiquetas modificado:
for (k=0;k<n;k++)V[k]=Va[k];  
// Los valores de registro vuelven a cero,listo para una nueva iteracion.  
for (k=0;k<n;k++)registro[k]=0;  

// Imprimimos todas las aristas de nuestroo arbol:

printf("\nE%d={",contador);
for(i=0;i<n;i++) for(j=i;j<n;j++) if(Arbol[i][j]==1) printf("{%d,%d},",i+1,j+1);
printf("\b}\n");
for(k=0;k<n-1;k++) if(V[k]!=V[k+1]) bandera=1 ;
// Si no se logra entrar a  "if(V[k]!==V[k+1])" ni una sola vez,significara 
// que todas las etiquetas tienen un solo valor,por lo cual bandera seguira 
// con valor 0,terminando con el bucle while.
contador++;
}
printf("\nV={");
for(t=0;t<n;t++)printf("%d, ",t+1);
printf("\b\b}\n   ");
for(t=0;t<n;t++){
if((t+1)/10==0)printf("%c  ",V[t]);
else printf(" %c  ",V[t]);
}
printf("\n------------------------------------------------------------------");
printf("\n");
}
}while(opcion!=6);
}// FIN DE PROGRAMA.		
\end{lstlisting}
\section{Pruebas y Resultados}
\subsection{Pruebas de Algoritmo de Jarnick mediante Arrays}
\subsection{Pruebas de Algoritmo de Jarnick mediante Estructuras}
\subsection{Pruebas de Algoritmo de Boruvka mediante Arrays}
\section{Conclusi\'on}


\end{document}
